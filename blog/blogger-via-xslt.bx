<?xml version='1.0' encoding='utf-8'?>
<blog>
<entry when='20051015T181052'>
<title>Blogger via XSLT</title>
<category>xslt</category>
<body>
<p>The last few days I've been setting up <a href='http://susansenator.com/blog'>my wife's brand-new blog</a>.
For some reason, I went with <a href='http://blogger.com'>Blogger</a> as a technology.
Because her site (like this one) is static HTML
generated by XSLT on my laptop, I wanted to generate the Blogger template the same way.
That way, the template would have the same look and feel as the rest of the site, and when the overall
look changes, the template would change too.
</p>

<p>Blogger templates are like most other templating systems: they look like HTML files, with
<a href='http://help.blogger.com/bin/topic.py?topic=39'>strange foreign Blogger-specific tags</a> in them.
The problem with generating Blogger templates with XSLT is that the "tags" in the template are
not well-formed XML.  So I had to resort to some tricks and compromises to make it all work.
</p>

<p>The end result works, but is a bit icky in the middle.  If you're interested in the details
of stuff like this, read on.</p>

<more>

<p>Here's a typical piece of a Blogger template:</p>

<code><![CDATA[
<Blogger>
   <BlogDateHeader>
      <h3><$BlogDateHeaderDate$></h3>
   </BlogDateHeader>
   <BlogItemTitle>
      <h2>
         <a href="<$BlogItemURL$>"><$BlogItemTitle$></a>
      </h2>
   </BlogItemTitle>
]]></code>

<p>The &lt;Blogger> and &lt;BlogDateHeader> tags are simple enough: they're OK as XML.
But the dollar signs in &lt;$BlogDateHeaderDate$> are troublesome,
as is the &lt;a> tag at line 7 with the angle brackets in the attribute value.
</p>

<p>What I ended up doing was adding these clauses to my stylesheet:</p>

<code lang='xslt'><![CDATA[
<xsl:stylesheet
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="1.0"

    xmlns:b='http://www.stellated.com/blogger'
    xmlns:ba='http://www.stellated.com/bloggerlink'
    xmlns:bd='http://www.stellated.com/bloggerdollar'
    >

<xsl:template match='b:*'>
    <xsl:element name='{local-name()}'>
        <xsl:apply-templates />
    </xsl:element>
</xsl:template>

<xsl:template match='ba:*'>
    <a>
        <xsl:attribute name='href'>
            <xsl:text disable-output-escaping='yes'>&lt;$</xsl:text>
            <xsl:value-of select='local-name()' />
            <xsl:text disable-output-escaping='yes'>$&gt;</xsl:text>
        </xsl:attribute>
        <xsl:copy-of select='@*' />
        <xsl:apply-templates />
    </a>
</xsl:template>

<xsl:template match='bd:*'>
    <xsl:text disable-output-escaping='yes'>&lt;$</xsl:text>
    <xsl:value-of select='local-name()' />
    <xsl:text disable-output-escaping='yes'>$&gt;</xsl:text>
</xsl:template>
]]></code>

<p>The disable-output-escaping attribute is essential here, as we're creating
XML-like structures that aren't XML.  It lets us output angle brackets as
true angle brackets, and put together a "tag" the hard way, flying under the
radar of the XML parser that reads the XSLT sheet.</p>

<p>I've created three namespaces: b for ordinary Blogger tags, bd for Blogger
tags with dollar signs in them, and ba for a tags that need a blogger tag in the
href attribute.</p>

<p>Now I can put this into my page template input file:</p>

<code><![CDATA[
<b:Blogger>
   <b:BlogDateHeader>
      <h3><bd:BlogDateHeaderDate/></h3>
   </b:BlogDateHeader>
   <b:BlogItemTitle>
      <h2>
         <ba:BlogItemURL><bd:BlogItemTitle/></ba:BlogItemURL>
      </h2>
   </b:BlogItemTitle>
]]></code>

<p>and the output will be the desired Blogger template tags as shown above.
Unfortunately, there's even wierder stuff in typical Blogger templates.
They have start tags and end tags individually conditionalized in ways that
completely violate XML tag nesting:</p>

<code><![CDATA[
<h2>
   <BlogItemURL><a href="<$BlogItemURL$>"></BlogItemURL>
   <$BlogItemTitle$>
   <BlogItemURL></a></BlogItemURL>
</h2>
]]></code>

<p>I didn't even attempt this, since I didn't want the conditionalization anyway.
And there are "tags" which expand to attributes for an enclosing tag:
</p>

<code><![CDATA[
<a href="<$BlogItemCommentCreate$>" <$BlogItemCommentFormOnClick$>>
   <$BlogItemCommentCount$> comments
</a>
]]></code>

<p>That one I completely punted on, resorting to a special-purpose XSLT template for it:</p>

<code lang='xslt'><![CDATA[
<xsl:template match='bloggercommentlink'>
    <xsl:text disable-output-escaping='yes'>&lt;a href="&lt;$BlogItemCommentCreate$>" &lt;$BlogItemCommentFormOnclick$>></xsl:text>
        <xsl:apply-templates />
    <xsl:text disable-output-escaping='yes'>&lt;/a></xsl:text>
</xsl:template>
]]></code>

<p>Like I said, the end result works.  I had to avoid the constructs that were really hairy,
but none of them were things I missed.</p>

</more>

</body>
</entry>
</blog>
