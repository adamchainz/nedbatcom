<?xml version='1.0' encoding='utf-8'?>
<blog>
<entry when='20130827T071017' draft='y'>
<title>Names and values: making a game board</title>
<category></category>
<body>

<!--[[[cog
    from helpers.graphy import CogGraphviz, tutor_a_tag
    CogGraphviz.we_are_here('blog', 'gameboard_dot')
]]]-->
<!--[[[end]]]-->

<p>In <apage pref='text/names.px'/>, I described how Python's names and values
    work.  There I posed some other questions.  Let's answer some of them.
    Here's some more about that TODO.</p>

<h1>Making a game board</h1>

<p>Beginners like writing games, and games often involve a grid-like board.
    Python doesn't have a native two-dimensional array, so we use a list of lists.
    Making a checkerboard full of zeros can be done with a literal list:</p>

<code lang="py"><![CDATA[
board = [
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
]
]]></code>

<p>but that's tedious, especially if you need a 100<times/>100 board. Even if
    you don't, it seems like we could do it more compactly.  Python lets you
    multiply lists by integers to replicate elements.  This code produces a
    list of eight zeros:</p>

<code lang="py"><![CDATA[
row = [0] * 8
]]></code>

<p>so let's try making a board:</p>

<code lang="py"><![CDATA[
# Construct the empty board
board = [ [0]*8 ] * 8
# Put a 1 in the upper-left corner
board[0][0] = 1
pprint(board)
]]></code>

<code><![CDATA[
[[1, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0, 0, 0, 0]]
]]></code>

<p>Huh? Somehow setting one cell changed the first cell in every row!?</p>

<p>Remember that Python never implicitly copies data.  When you replicate a list
    with multiplication, you get the same value referenced many times.  When we
    made the single row, we made a list with eight references to the same zero:</p>

<figurep>
    <!--[[[cog
    g = CogGraphviz()
    g.codelabel("row = [0] * 8")
    g.dot("""
        row [NAMEATTRS]
        { rank="same"
        X [style="invis"]
        0 [INTATTRS]
        }
        list1 [shape=record, label="{<0>|<1>|<2>|<3>|<4>|<5>|<6>|<7>}"]
        row -> list1:0
        list1:0:s -> 0
        list1:1:s -> 0
        list1:2:s -> 0
        list1:3:s -> 0
        list1:4:s -> 0
        list1:5:s -> 0
        list1:6:s -> 0
        list1:7:s -> 0
        list1:7:e -> X [label="", style="invis", weight=20]
        X -> 0 [label="", style="invis"]
        """)
    g.img(alt="row is a list with eight references to the same zero") 
    ]]]-->
    <img src="blog/gameboard_dot/d000.png" alt="row is a list with eight references to the same zero" align="top" scale="0.5"/>
    <!--[[[end]]]-->
</figurep>

<p>When we make the board, the same behavior of replicating a list applies, so the board is
    actually eight references to the same list:</p>

<figurep>
    <!--[[[cog
    g = CogGraphviz()
    g.codelabel("board = [ [0]*8 ] * 8")
    g.dot("""
        board [NAMEATTRS]
        list1 [shape=record, label="{<0>|<1>|<2>|<3>|<4>|<5>|<6>|<7>}"]
        {
            rankdir=LR;
            rank="same";
            list2 [shape=record, label="{<0>|<1>|<2>|<3>|<4>|<5>|<6>|<7>}"]
        }
        board -> list2:0
        {
            rankdir=LR;
            rank="same";
            X [style="invis"]
            0 [INTATTRS]
        }
        list1:0:s -> 0
        list1:1:s -> 0
        list1:2:s -> 0
        list1:3:s -> 0
        list1:4:s -> 0
        list1:5:s -> 0
        list1:6:s -> 0
        list1:7:s -> 0

        list2:0:s -> list1:0
        list2:1:s -> list1:0
        list2:2:s -> list1:0
        list2:3:s -> list1:0
        list2:4:s -> list1:0
        list2:5:s -> list1:0
        list2:6:s -> list1:0
        list2:7:s -> list1:0
        list1:7:e -> X [label="", style="invis", weight=20]
        X -> 0 [label="", style="invis"]
        """)
    g.img(alt="row is a list with eight references to the same zero") 
    ]]]-->
    <img src="blog/gameboard_dot/d001.png" alt="row is a list with eight references to the same zero" align="top" scale="0.5"/>
    <!--[[[end]]]-->
</figurep>

<p>When we assign to board[0][0], we are changing one element, but that element is visible through
    all eight rows, because all eight rows are actually references to the same list:</p>

<figurep>
    <!--[[[cog
    g = CogGraphviz()
    g.codelabel("board[0][0] = 1")
    g.dot("""
        board [NAMEATTRS]
        list1 [shape=record, label="{<0>|<1>|<2>|<3>|<4>|<5>|<6>|<7>}"]
        list2 [shape=record, label="{<0>|<1>|<2>|<3>|<4>|<5>|<6>|<7>}"]
        board -> list2:0
        subgraph nums {
            rankdir=LR;
            rank="same";
            X [style="invis"]
            0 [INTATTRS]
            1 [INTATTRS]
            }
        list1:0:s -> 1 [weight=10]
        list1:1:s -> 0
        list1:2:s -> 0
        list1:3:s -> 0
        list1:4:s -> 0
        list1:5:s -> 0
        list1:6:s -> 0
        list1:7:s -> 0
        list1:7:e -> X [label="", style="invis", weight=20]
        list2:0:s -> list1:0
        list2:1:s -> list1:0
        list2:2:s -> list1:0
        list2:3:s -> list1:0
        list2:4:s -> list1:0
        list2:5:s -> list1:0
        list2:6:s -> list1:0
        list2:7:s -> list1:0
        X -> 0 [label="", style="invis"]
        0 -> 1 [label="", style="invis"]
        """)
    g.img(alt="row is a list with eight references to the same zero") 
    ]]]-->
    <img src="blog/gameboard_dot/d002.png" alt="row is a list with eight references to the same zero" align="top" scale="0.5"/>
    <!--[[[end]]]-->
</figurep>

<p>Perhaps this is clearer if you consider that these two ways to make the board
    are exactly the same:</p>

<code lang="py"><![CDATA[
# Make it all at once
board = [ [0] * 8 ] * 8

# Make a row, then make a board
row = [0] * 8
board = [ row ] * 8
]]></code>

<p>Assigning the row to its own variable doesn't change the behavior, but when
    we see it assigned to a name, it's more obvious that you'll get eight
    references to the same row.</p>

<p>So why didn't that one assignment change every zero in the board? As the
    diagram shows, there's only one zero referred to by all 64 elements.
    TODO.</p> 

<p>The compact way to make a board that works correctly is to use a list
    comprehension to make each row:</p>

<code lang="py"><![CDATA[
board = [ [0]*8 for _ in range(8) ]
]]></code>

<p>With this code, we use [0]*8 to make the row, which is fine because
    assignment will correctly update a single element in that row.  The list
    comprehension makes a list with eight of those, but instead of each one
    being a reference to the same row, the row is recomputed each time, so a
    new list is made for each row.</p>

<p>I used underscore as the loop variable as a convention that means, I won't 
    be using this value at all.  Underscore isn't special, it's just a valid
    identifier that is used in cases like these.</p>


</body>
</entry>
</blog>
