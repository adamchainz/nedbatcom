<page title="Python Iteration">
<history>
<what when="20120424T144700">Created</what>
</history>

<p>This is a presentation I gave at <a href="http://bostonpython.com">Boston Python</a> in April of 2012.</p>

<p>There's a <a href="http://www.ustream.tv/recorded/22100783">video of me talking</a>, but you can't read the slides
in it, so you might want to follow along here.
Also, clicking the slide images on this page will jump into the full presentation at that point.</p>

<h1>Python Iteration</h1><figurep href="text/iter/iter.html#1"><img src="text/iter_000.png" alt="Python Iteration"/></figurep><p>This is a short talk for a Boston Python night called "Fundamental Topics."
    It's intended to help beginners understand Python at a deeper level, and also
    to give intermediate learners some new tidbits.</p><p>Python has a nice model of abstract iteration which can be used to
    increase the expressiveness of your programs.  I think Python's iteration
    tools are one of the most underused features of the language, especially
    by programmers coming from other "similar" languages.</p><p>My goal here is to show Python iteration in a light that would encourage
    programmers to explore more of its possibililities.</p><figurep href="text/iter/iter.html#2"><img src="text/iter_001.png" alt="Iteration"/></figurep><p>Let's say you have a list of eight numbers, and you want to print each
    of them.  One way to do it is shown in the first code sample: start a
    counter at zero, and as long as the counter is less than the length of the
    list, access that element of the list, and print it. Then increment the
    counter, and continue on to the next element.  Eventually, the while loop
    will run over the whole list.</p><p>Note we used "less than the length of the list" because list indexes run
    from zero to len-1.</p><p>This style of iteration works, and is the least common denominator: this
    way of thinking about the loop can be written in almost any language.</p><p>In Python, there's a simpler way to have a loop that ranges from zero to
    N-1. You can use the idiom "for i in range(N)", as we see next.  Here i
    again takes on values starting with zero and going up to the last index of
    my_list.  This is the Python version of C's classic for-loop structure.</p><p>C programmers coming to Python often end here: they are used to a loop 
    that iterates over integers, and range() gives them a nice compact way to 
    do it.</p><p>But Python gives us a much more natural way to loop over the values in
    my_list.  Rather than iterating over indexes, and using the index i to
    get the value we really want from the list, we can simply loop over the
    values directly.</p><p>The last code sample shows the right way to write this loop.  "for v in my_list"
    gives us each value in my_list in the variable v, with no need to fiddle 
    around with the index i at all.  What started as a five-line while loop
    with two variables is now a two-line loop with only one.</p><figurep href="text/iter/iter.html#3"><img src="text/iter_002.png" alt="The for loop"/></figurep><p>The for loop is Python's versatile swiss-army-knife iteration tool.  It
    can iterate over all sorts of Python objects.  Any Python object can be
    "iterable," which means it can provide a stream of values.  Any iterable
    can be used in a for loop.  The for loop extracts values from the stream,
    assigns them to the name, and execute the statements in the body once for
    each value.</p><p>On the face of it, this seems simple.  But this simplicity provides
    great power. The for loop can be used in all sorts of situations to iterate
    all sorts of values.  A key idea in this talk is that you can often re-shape
    your iterations to use the for loop more powerfully.</p><figurep href="text/iter/iter.html#4"><img src="text/iter_003.png" alt="Lists"/></figurep><p>There are many different iterable objects in Python, and each provides
    its stream of values in its own way.  As we've seen, if you iterate
    a list, it will provide its elements in order.</p><figurep href="text/iter/iter.html#5"><img src="text/iter_004.png" alt="Strings"/></figurep><p>If you iterate a string, it will produce a stream of one-character strings,
    one for each character in the string.</p><figurep href="text/iter/iter.html#6"><img src="text/iter_005.png" alt="Dicts"/></figurep><p>If you iterate a dictionary, it will give you its keys.  This might be a
    little surprising, what about the values?  Dictionaries are treated like a
    container of keys, where each key also has a value associated with it.  If
    you want, you can choose to use methods on the dictionary to iterate over
    its values, or over its key/value pairs.</p><p>Notice that the keys appear in a surprising order.  Dictionaries have no
    inherent order.  When iterated, they produce their keys in an arbitrary
    order.  Each iterable can decide the semantics of its sequence.
    Dictionaries promise to give you all of the keys, with no extras, and
    no duplicates, but make no guarantee about the order of the keys.</p><figurep href="text/iter/iter.html#7"><img src="text/iter_006.png" alt="Files"/></figurep><p>An open file is an iterable, its values are strings, one for each line
    in the file.  This is extremely convenient, since this is often the way
    text files are consumed, one line at a time.</p><p>In this example I've printed repr(line) so you can see that the lines
    still have a newline at the end, since every byte in the file should be 
    provided somewhere.</p><figurep href="text/iter/iter.html#8"><img src="text/iter_007.png" alt="Other uses for iterables"/></figurep><p>Python uses iterables in lots of places, not just in for loops. 
    For example, the list() function creates a list using the values it
    gets from its iterable argument. Keep in mind, the argument can be
    any iterable.  list(my_dict) will produce a list of the dictionary's
    keys.  list(my_open_file) will produce a list of the lines of the file.</p><p>List comprehensions are a concise way to create a list using a 
    computation on an iterable.  They are very powerful, but are outside the
    scope of this presentation.</p><p>The sum() function takes an iterable, and returns the sum of all the
    values it finds.  The iterable has to be a stream of numbers.  The min()
    function takes an iterable of comparable values (such as strings or numbers),
    and returns the smallest value in the stream.  Of course there is a max()
    function as well.</p><p>These are just a few examples of using iterables outside of for loops,
    as streams of values that can be passed to functions, computed with,
    and so on.</p><figurep href="text/iter/iter.html#9"><img src="text/iter_008.png" alt="Any object can be iterable"/></figurep><p>Not only does Python use iterables in lots of places, but lots
    of different kinds of values can be iterable.  Here are two examples
    from the standard library.</p><p>The re module searches for a regex pattern in a string.  The finditer
    function takes a pattern and a string, and iterates over all the places
    that pattern matches that string.  It's a good way to process a number of
    pattern matches in a simple way.</p><p>In the os module, the walk function takes a directory name, and iterates
    over all the subdirectories in that tree.</p><p>These are just two examples of use iterables to represent a variety of
    kinds of iteration, and doing it naturally without resorting to index
    variables.</p><figurep href="text/iter/iter.html#10"><img src="text/iter_009.png" alt="Controlling loops"/></figurep><p>As with many other languages, you can affect the execution of the
    loop body with the break and continue statements.  The break statement will
    prematurely end the loop, ignoring the unused values in the iterable.  The 
    next statement executed will be the one following the for loop.</p><p>In the first code sample, we have a typical use of break: we're
    iterating a collection of things, examining each value in turn, and when we
    find the one we want, the break statement ends the loop early.

    </p><p>The continue statement ends the current loop execution, but goes on to the 
    next value in the iterable.  You can use it to check a value, and skip it if
    you don't want to deal with it, but still want to go on and use the other values
    from the iterable.</p><p>The second code sample shows a typical use of continue: some of the
    values in the collection of things are uninteresting.  We skip them with
    the continue statement, which immediately goes to the top of the loop body,
    getting the next value from the iterator.</p><figurep href="text/iter/iter.html#11"><img src="text/iter_010.png" alt="A for loop is like many assignments"/></figurep><p>A for loop actually acts like an assignment statement.  An assignment
    has a name on the left side of the equals sign, and a value on the right
    side.  Instead of a name and a value, the for loop has a name and a stream
    of values.</p><p>For each value in the stream, the for loop assigns the name to the
    value, and then executes the statements in the body of the loop.  So the
    behavior is a stream of: assignment, body, assignment, body, assignment,
    body, and so on.</p><p>To get the full power from for loops, it's important to keep this
    assignment behavior in mind.</p><figurep href="text/iter/iter.html#12"><img src="text/iter_011.png" alt="Multiple assignment"/></figurep><p>Python's assignment statement is actually more versatile than just a
    name and a value.  You can assign to more than one name at once if the
    right-hand side also has a number of values, and there are as many values
    as there are names.</p><p>The names and values are paired up.  Each name gets assigned a
    corresponding value.</p><p>In this code sample, we assign two numbers to two names with one
    assignment statement. The right-hand value is a tuple of two values,
    so the two elements (1, 2) are assigned to the two names (a, b).</p><figurep href="text/iter/iter.html#13"><img src="text/iter_012.png" alt="Multiple loop assignment"/></figurep><p>Since a for loop is like an assignment statement, and assignment
    statements can assign to more than one name at once, for loops can also
    assign to more than one name at once.</p><p>In this example, my_pairs is a list of pairs of numbers.  If we iterate
    over it, each iteration of the loop will get the next pair of numbers.  The
    equivalent assignment statements are shown. This loop is like assigning "a,
    b = (1, 2)", making a 1 and b 2.  The loop body is executed, and then the
    next pair is assigned to a and b.</p><p>The rule still applies that the number of names has to match the number
    of values.  In this case, each value in the list is a tuple with two
    elements, and we use two names in the for loop, so the number of values and
    names match.</p><p>This can be a little confusing, because we're talking about a stream of
    values, where each value is itself a tuple of two values.  The rule about
    the number of names matching the number of values applies to the tuples,
    not to the stream. This for loop can handle any number of pairs.</p><figurep href="text/iter/iter.html#14"><img src="text/iter_013.png" alt="enumerate() makes useful pairs"/></figurep><p>In addition to looping over iterables, you can manipulate iterables to produce
    new iterables that might be more convenient for you.  The built-in enumerate()
    function takes one iterable, and produces a stream of pairs.  Each value from the
    iterable is paired with a number, starting with zero.</p><p>In our example, the list "names" is given to enumerate() which iterates the list,
    giving the values "Anne", "Betty", "Carla".  It pairs those with the number 0, 1, 2,
    to produce a stream of pairs.</p><p>Note in the first code sample, we use only one name in the for loop.  Although
    the stream contains pairs, they can still be assigned to one name.  The name will
    be assigned each pair in turn.</p><p>We can use multiple-name assignment to get those pairs as two separate values,
    as in the bottom example.  The variables num and name are assigned to the number
    of each name, and the name itself, from the list "names".  This is a convenient way
    to iterate over the values in a stream while also using their index.</p><figurep href="text/iter/iter.html#15"><img src="text/iter_014.png" alt="zip() makes pair-wise loops"/></figurep><p>The zip() built-in function takes a pair of streams, and "zips" them
    together to produce a stream of pairs.  In this example, we have two
    lists: "names" has names in it, and "ages" has ages that go with the
    names.  zip(names, ages) will produce a stream of pairs, each pairing
    a name with the corresponding age.  By using multiple assignment, we
    unpack the pairs into the variables name and age.</p><figurep href="text/iter/iter.html#16"><img src="text/iter_015.png" alt="dict() accepts a stream of pairs"/></figurep><p>Here's another example of the power of iterables.  The dict() function
    will accept a stream of key/value pairs, and construct a dictionary 
    from them.  If we have two parallel lists, "names" containing strings,
    and "ages" containing numbers, zip(names, ages) will produce a stream
    of pairs, and dict() will use that stream, and produce exactly the
    dictionary we want.</p><figurep href="text/iter/iter.html#17"><img src="text/iter_016.png" alt="Generators: your own iterables"/></figurep><p>The last topic we'll cover here is generators, which is a big topic,
    but an important one.  Generators are a way to create your own iterables
    by writing a function.</p><p>In a normal function, calling the function returns one value, with
    the return statement.  A generator looks just like a function, but instead
    of a return statement, it has one or more yield statements.  Calling
    the function creates an iterable, and iterating it runs the code in 
    the function.  Each yield statement executed produces another value
    in the stream.</p><p>Here's an example of a extremely simple generator, just containing
    two yield statements.  If you iterate it with a for loop, you can see
    that hello_world() produced a stream of two values, "Hello", and "world".</p><p>Real generators are not this simple, typically the body of the function would
    itself have a loop, with yield statments within it.</p><figurep href="text/iter/iter.html#18"><img src="text/iter_017.png" alt="Generators"/></figurep><p>Generators can be confusing.  They look very similar to functions,
    but have very important differences.  First, calling the generator doesn't
    immediately begin running the code in the generator, it simply creates
    an iterable.  When the for loop or other consumer of the iterable starts
    pulling values from the stream, then the code in the generator begins 
    executing.</p><p>When a yield statement is encountered, execution is suspended, and
    the value is used as the next value in the stream.  With a regular function,
    a return statement ends the function for good.  But with a generator, the
    current state of the execution is remembered.  When the next value is
    requested from the iterable, execution continues in the generator where
    it left off, after the yield statement.  The next value in the stream is
    produced when the yield statement is executed again.  All the local
    variables in the generator retain their values for the whole course of 
    the stream.  This makes it a very convenient way to write iterables.</p><p>As an example, we've written a "repeat" generator.  It takes a value
    and a count of the number of times it should repeat.  This generator will
    produce a stream of "num" instances of "val", and then stop.</p><p>The code in the generator is very simple: as long as num is more than 
    zero, yield val, and then decrement num.  This will produce our stream
    of num instances of val.  Notice that after producing the first value,
    execution continues after the yield statement, it doesn't start at the top
    of the generator again.</p><p>The current value of our local variable num is preserved for the lifetime
    of the generator.</p><p>The iterator finally ends when the generator returns, either with an
    explicit return statement, or by executing the last statement in the
    generator.</p><figurep href="text/iter/iter.html#19"><img src="text/iter_018.png" alt="Abstracting your iteration"/></figurep><p>As a real-world example of abstracing iteration, consider a program that 
    reads a text file and acts on the lines in it.  Our file can have comments,
    which are lines starting with '#', and can also have blank lines, both of 
    which should be ignored.</p><p>Here's a sketch of the program.  We open the file, then loop over the lines
    in the file.  We strip the whitespace from the ends of the line, then consider
    whether the line starts with '#'. If it does, we continue the loop, which skips
    this line of text and goes on to the next line in the file.  Similarly, if the
    line is blank, we continue to the next line in the file.</p><p>Finally, if the line isn't a comment or blank, then we process it in whatever
    way we like.  When all of the logic is considered, this loop calls do_something()
    on all of the non-blank non-comment lines from the file.</p><figurep href="text/iter/iter.html#20"><img src="text/iter_019.png" alt="Your own generator"/></figurep><p>Our line-processing program works just fine, but it mixed together two 
    concerns. The first is, what are the interesting lines in the file, and which should
    be ignored?  Second, what should we do with the interesting lines?  These two
    questions may have nothing to do with each other.  You may need to re-use the
    first, for example, in a larger program that processes a few different kinds
    of files.</p><p>Using a generator, we can split this loop into two parts.  The first part,
    which lines are interesting, can be implemented as a generator.  Our interesting_lines()
    takes an open file and loops over its lines.  It uses the same code as before to 
    skip over comment or blank lines, but then instead of processing the interesting line,
    it simply yields it.</p><p>Now we can use interesting_lines(f) in a for loop, and the loop will only see
    the interesting lines, all the uninteresting stuff has been skipped in the generator.
    This makes it easy for us to reuse the line-skipping logic in other loops.</p><p>Notice that our generator interesting_lines() is actually a pure filter: 
    it accepts a line-producing iterable of any sort, it doesn't have to be an open file.
    And it produces a stream of lines, by picking the ones it likes from the input
    stream.</p><p>Notice also that we have re-thought our iteration: in the original code, we were
    iterating over all the lines in the file, and "manually" skipping over the uninteresting
    ones.  With our new generator, we can think instead of iterating over the interesting
    lines in the file.  This lets us work at a higher level of abstraction.</p><figurep href="text/iter/iter.html#21"><img src="text/iter_020.png" alt="Looping over a grid"/></figurep><p>As a last example of rethinking iteration, consider looping over a two-dimensional
    structure like a spreadsheet.  A simple way to do it is to use two nested loops:
    the first loops over the rows, and the second loops over the columns.  Together
    the two loop variables can be used to access a cell in the spreadsheet.</p><p>There's a problem with this, though: suppose we are checking the cells for
    some condition, and when we find the condition, we want to stop looking through
    cells.  There's no nice way to break out of two loops at once.  The break statement
    shown here will only break out of the column loop, and will leave the row loop
    untouched, so the search will continue from the beginning of the next row.</p><p>There are ways to write the code so that both loops will end, but they are
    messy and confusing.</p><figurep href="text/iter/iter.html#22"><img src="text/iter_021.png" alt="Abstract away the double loop"/></figurep><p>A more interesting solution is to change the iteration by abstracting away the
    two-dimensional nature.  Here we have a generator called twod_range(): it takes
    a width and height, and produces a stream of pairs (x,y) that range over the entire
    2D space of coordinates.  It does this using the same double-nested loop we had before,
    but now the loop body simply yields the tuple we need to represent the coordinates.</p><p>Our main loop now changes from a doubly-nested loop to a regular single loop.
    Each iteration of twod_range() produces another coordinate pair, and we can process 
    the coordinates just as we did before, except now when we've found the cell we want,
    we can just break out of the loop, and all is well.</p><p>This is a more unusual loop change than we've seen before.  Here we changed a 
    double loop into a single loop by re-thinking what we were iterating over.  It's 
    more natural to think of this program as "looking at every cell in the spreadsheet,"
    rather than the more tiresome, "once for each row, look at every cell in the row."</p><p>Our generator lets us define "look at every cell" abstractly so that our main
    program can use the most expressive way to get the job done.</p><figurep href="text/iter/iter.html#23"><img src="text/iter_022.png" alt="Other topics"/></figurep><p>There is much more in this topic than can be covered in a short talk:</p><ul><li>The "iterator protocol" is the actual sequence of function and
        method calls that happen to create and consume iterables.  It can
        be useful for advanced uses of iterables.</li>

        <li>When you define a class, you can make it iterable by defining
        a __iter__() method.</li>

        <li>List comprehensions are a compact way to describe a list in terms
        of a computation over another iterable.  They can make your code very
        concise.</li>

        <li>Generator expressions are a lot like list comprehensions, but
        generate values on demand, like generators.</li>

        <li>itertools is a module in the Python standard library full of 
        functions for creating, manipulating, and consuming iterables.</li>

    </ul><figurep href="text/iter/iter.html#24"><img src="text/iter_023.png" alt="sum(slides)"/></figurep><p>To summarize: iteration is a fundamental tool in all programming.  Python
    has a simple yet powerful model for iteration that is used throughout the
    language and standard library.  Using the tool that iterables provide,
    you can re-think your iterations to make them clearer, more concise,
    and more powerful.</p>


    



    

    

    



    

    



    

    

    

    



    

    



    

    

    

    

    



    

    

    







    

    

    



    

    

    



    

    



    

    



    

    



    

    

    



    

    

    



    



    







    



    

    

    

    

    

    



    

    

</page>