<?xml version="1.0" encoding="utf-8" ?>

<page title='Coverage API' >

  <history>
<what when='20090524T134300'>brand new docs.</what>
<what when='20090613T164000'>final touches for 3.0</what>
<what when='20100221T151500'>docs for 3.3 (on the plane back from PyCon)</what>
<what when='20100725T211700'>updated for 3.4.</what>
<what when='20121111T235800'>added a bit of clarification.</what>
<what when='20140819T132600'>change class name to Coverage</what>
</history>
<p>The API to coverage.py is very simple, contained in a single module called
<cite>coverage</cite>.  Most of the interface is in a single class, called
<cite>Coverage</cite>.  Methods on the Coverage object correspond roughly to operations
available in the command line interface. For example, a simple use would be:</p>
<code lang="python">import coverage

cov = coverage.Coverage()
cov.start()

# .. call your code ..

cov.stop()
cov.save()

cov.html_report()</code>
<h1 id="the-coverage-module">The coverage module</h1>
<dl class="class">
<dt id="coverage.Coverage">
<em class="property">class </em><tt class="descclassname">coverage.</tt><tt class="descname">Coverage</tt>(<em>data_file=None</em>, <em>data_suffix=None</em>, <em>cover_pylib=None</em>, <em>auto_data=False</em>, <em>timid=None</em>, <em>branch=None</em>, <em>config_file=True</em>, <em>source=None</em>, <em>omit=None</em>, <em>include=None</em>, <em>debug=None</em>, <em>debug_file=None</em>, <em>concurrency=None</em>, <em>plugins=None</em>)</dt>
<dd><p>Programmatic access to coverage.py.</p>
<p>To use:</p>
<code lang="python">from coverage import coverage

cov = Coverage()
cov.start()
#.. call your code ..
cov.stop()
cov.html_report(directory='covhtml')</code>
<p><cite>data_file</cite> is the base name of the data file to use, defaulting to
&#8221;.coverage&#8221;.  <cite>data_suffix</cite> is appended (with a dot) to <cite>data_file</cite> to
create the final file name.  If <cite>data_suffix</cite> is simply True, then a
suffix is created with the machine and process identity included.</p>
<p><cite>cover_pylib</cite> is a boolean determining whether Python code installed
with the Python interpreter is measured.  This includes the Python
standard library and any packages installed with the interpreter.</p>
<p>If <cite>auto_data</cite> is true, then any existing data file will be read when
coverage measurement starts, and data will be saved automatically when
measurement stops.</p>
<p>If <cite>timid</cite> is true, then a slower and simpler trace function will be
used.  This is important for some environments where manipulation of
tracing functions breaks the faster trace function.</p>
<p>If <cite>branch</cite> is true, then branch coverage will be measured in addition
to the usual statement coverage.</p>
<p><cite>config_file</cite> determines what config file to read.  If it is a string,
it is the name of the config file to read.  If it is True, then a
standard file is read (&#8221;.coveragerc&#8221;).  If it is False, then no file is
read.</p>
<p><cite>source</cite> is a list of file paths or package names.  Only code located
in the trees indicated by the file paths or package names will be
measured.</p>
<p><cite>include</cite> and <cite>omit</cite> are lists of filename patterns. Files that match
<cite>include</cite> will be measured, files that match <cite>omit</cite> will not.  Each
will also accept a single string argument.</p>
<p><cite>debug</cite> is a list of strings indicating what debugging information is
desired. <cite>debug_file</cite> is the file to write debug messages to,
defaulting to stderr.</p>
<p><cite>concurrency</cite> is a string indicating the concurrency library being used
in the measured code.  Without this, coverage.py will get incorrect
results.  Valid strings are &#8220;greenlet&#8221;, &#8220;eventlet&#8221;, &#8220;gevent&#8221;, or
&#8220;thread&#8221; (the default).</p>
<p><cite>plugins</cite> TODO.</p>
<dl class="method">
<dt id="coverage.Coverage.analysis">
<tt class="descname">analysis</tt>(<em>morf</em>)</dt>
<dd><p>Like <cite>analysis2</cite> but doesn&#8217;t return excluded line numbers.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.analysis2">
<tt class="descname">analysis2</tt>(<em>morf</em>)</dt>
<dd><p>Analyze a module.</p>
<p><cite>morf</cite> is a module or a filename.  It will be analyzed to determine
its coverage statistics.  The return value is a 5-tuple:</p>
<ul class="simple">
<li>The filename for the module.</li>
<li>A list of line numbers of executable statements.</li>
<li>A list of line numbers of excluded statements.</li>
<li>A list of line numbers of statements not run (missing from
execution).</li>
<li>A readable formatted string of the missing line numbers.</li>
</ul>
<p>The analysis uses the source file itself and the current measured
coverage data.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.annotate">
<tt class="descname">annotate</tt>(<em>morfs=None</em>, <em>directory=None</em>, <em>ignore_errors=None</em>, <em>omit=None</em>, <em>include=None</em>)</dt>
<dd><p>Annotate a list of modules.</p>
<p>Each module in <cite>morfs</cite> is annotated.  The source is written to a new
file, named with a &#8221;,cover&#8221; suffix, with each line prefixed with a
marker to indicate the coverage of the line.  Covered lines have &#8220;&gt;&#8221;,
excluded lines have &#8220;-&#8221;, and missing lines have &#8221;!&#8221;.</p>
<p>See <cite>coverage.report()</cite> for other arguments.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.clear_exclude">
<tt class="descname">clear_exclude</tt>(<em>which='exclude'</em>)</dt>
<dd><p>Clear the exclude list.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.combine">
<tt class="descname">combine</tt>()</dt>
<dd><p>Combine together a number of similarly-named coverage data files.</p>
<p>All coverage data files whose name starts with <cite>data_file</cite> (from the
coverage() constructor) will be read, and combined together into the
current measurements.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.erase">
<tt class="descname">erase</tt>()</dt>
<dd><p>Erase previously-collected coverage data.</p>
<p>This removes the in-memory data collected in this session as well as
discarding the data file.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.exclude">
<tt class="descname">exclude</tt>(<em>regex</em>, <em>which='exclude'</em>)</dt>
<dd><p>Exclude source lines from execution consideration.</p>
<p>A number of lists of regular expressions are maintained.  Each list
selects lines that are treated differently during reporting.</p>
<p><cite>which</cite> determines which list is modified.  The &#8220;exclude&#8221; list selects
lines that are not considered executable at all.  The &#8220;partial&#8221; list
indicates lines with branches that are not taken.</p>
<p><cite>regex</cite> is a regular expression.  The regex is added to the specified
list.  If any of the regexes in the list is found in a line, the line
is marked for special treatment during reporting.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.get_exclude_list">
<tt class="descname">get_exclude_list</tt>(<em>which='exclude'</em>)</dt>
<dd><p>Return a list of excluded regex patterns.</p>
<p><cite>which</cite> indicates which list is desired.  See <cite>exclude</cite> for the lists
that are available, and their meaning.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.html_report">
<tt class="descname">html_report</tt>(<em>morfs=None</em>, <em>directory=None</em>, <em>ignore_errors=None</em>, <em>omit=None</em>, <em>include=None</em>, <em>extra_css=None</em>, <em>title=None</em>)</dt>
<dd><p>Generate an HTML report.</p>
<p>The HTML is written to <cite>directory</cite>.  The file &#8220;index.html&#8221; is the
overview starting point, with links to more detailed pages for
individual modules.</p>
<p><cite>extra_css</cite> is a path to a file of other CSS to apply on the page.
It will be copied into the HTML directory.</p>
<p><cite>title</cite> is a text string (not HTML) to use as the title of the HTML
report.</p>
<p>See <cite>coverage.report()</cite> for other arguments.</p>
<p>Returns a float, the total percentage covered.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.load">
<tt class="descname">load</tt>()</dt>
<dd><p>Load previously-collected coverage data from the data file.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.report">
<tt class="descname">report</tt>(<em>morfs=None</em>, <em>show_missing=True</em>, <em>ignore_errors=None</em>, <em>file=None</em>, <em>omit=None</em>, <em>include=None</em>)</dt>
<dd><p>Write a summary report to <cite>file</cite>.</p>
<p>Each module in <cite>morfs</cite> is listed, with counts of statements, executed
statements, missing statements, and a list of lines missed.</p>
<p><cite>include</cite> is a list of filename patterns.  Modules whose filenames
match those patterns will be included in the report. Modules matching
<cite>omit</cite> will not be included in the report.</p>
<p>Returns a float, the total percentage covered.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.save">
<tt class="descname">save</tt>()</dt>
<dd><p>Save the collected coverage data to the data file.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.start">
<tt class="descname">start</tt>()</dt>
<dd><p>Start measuring code coverage.</p>
<p>Coverage measurement actually occurs in functions called after <cite>start</cite>
is invoked.  Statements in the same scope as <cite>start</cite> won&#8217;t be measured.</p>
<p>Once you invoke <cite>start</cite>, you must also call <cite>stop</cite> eventually, or your
process might not shut down cleanly.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.stop">
<tt class="descname">stop</tt>()</dt>
<dd><p>Stop measuring code coverage.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.sysinfo">
<tt class="descname">sysinfo</tt>()</dt>
<dd><p>Return a list of (key, value) pairs showing internal information.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.use_cache">
<tt class="descname">use_cache</tt>(<em>usecache</em>)</dt>
<dd><p>Control the use of a data file (incorrectly called a cache).</p>
<p><cite>usecache</cite> is true or false, whether to read and write data on disk.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.xml_report">
<tt class="descname">xml_report</tt>(<em>morfs=None</em>, <em>outfile=None</em>, <em>ignore_errors=None</em>, <em>omit=None</em>, <em>include=None</em>)</dt>
<dd><p>Generate an XML report of coverage results.</p>
<p>The report is compatible with Cobertura reports.</p>
<p>Each module in <cite>morfs</cite> is included in the report.  <cite>outfile</cite> is the
path to write the file to, &#8220;-&#8221; will write to stdout.</p>
<p>See <cite>coverage.report()</cite> for other arguments.</p>
<p>Returns a float, the total percentage covered.</p>
</dd></dl>

</dd></dl>

<h1>Starting coverage automatically</h1>
<p>This function is used to start coverage measurement automatically when Python
starts.  See <a class="reference internal" href="/code/coverage/subprocess.html#subprocess"><em>Measuring subprocesses</em></a> for details.</p>
<dl class="function">
<dt id="coverage.process_startup">
<tt class="descclassname">coverage.</tt><tt class="descname">process_startup</tt>()</dt>
<dd><p>Call this at Python startup to perhaps measure coverage.</p>
<p>If the environment variable COVERAGE_PROCESS_START is defined, coverage
measurement is started.  The value of the variable is the config file
to use.</p>
<p>There are two ways to configure your Python installation to invoke this
function when Python starts:</p>
<ol class="arabic">
<li><p class="first">Create or append to sitecustomize.py to add these lines:</p>
<code lang="python">import coverage
coverage.process_startup()</code>
</li>
<li><p class="first">Create a .pth file in your Python installation containing:</p>
<code lang="python">import coverage; coverage.process_startup()</code>
</li>
</ol>
</dd></dl>



<p class='pmn pmnbot'>
    <span class='p'>&#xab;&#xa0;<i>Previous:</i> <a href="/code/coverage/subprocess.html" title="previous topic">Measuring subprocesses</a></span>
    <span class='n'><i>Next:</i> <a href="/code/coverage/contributing.html" title="next topic">Contributing to coverage.py</a>&#xa0;&#xbb;</span>
</p>

</page>