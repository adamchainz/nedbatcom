<?xml version="1.0" encoding="utf-8" ?>

<page title='The Coverage class' index='no'>

  <span class="target" id="api-coverage"></span><dl class="class">
<dt id="coverage.Coverage">
<em class="property">class </em><code class="descclassname">coverage.</code><code class="descname">Coverage</code>(<em>data_file=None</em>, <em>data_suffix=None</em>, <em>cover_pylib=None</em>, <em>auto_data=False</em>, <em>timid=None</em>, <em>branch=None</em>, <em>config_file=True</em>, <em>source=None</em>, <em>omit=None</em>, <em>include=None</em>, <em>debug=None</em>, <em>concurrency=None</em>)<a class="headerlink" href="#coverage.Coverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Programmatic access to coverage.py.</p>
<p>To use:</p>
<code lang="python">from coverage import Coverage

cov = Coverage()
cov.start()
#.. call your code ..
cov.stop()
cov.html_report(directory='covhtml')</code>
<dl class="method">
<dt id="coverage.Coverage.__init__">
<code class="descname">__init__</code>(<em>data_file=None</em>, <em>data_suffix=None</em>, <em>cover_pylib=None</em>, <em>auto_data=False</em>, <em>timid=None</em>, <em>branch=None</em>, <em>config_file=True</em>, <em>source=None</em>, <em>omit=None</em>, <em>include=None</em>, <em>debug=None</em>, <em>concurrency=None</em>)<a class="headerlink" href="#coverage.Coverage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>data_file</cite> is the base name of the data file to use, defaulting to
&#8221;.coverage&#8221;.  <cite>data_suffix</cite> is appended (with a dot) to <cite>data_file</cite> to
create the final file name.  If <cite>data_suffix</cite> is simply True, then a
suffix is created with the machine and process identity included.</p>
<p><cite>cover_pylib</cite> is a boolean determining whether Python code installed
with the Python interpreter is measured.  This includes the Python
standard library and any packages installed with the interpreter.</p>
<p>If <cite>auto_data</cite> is true, then any existing data file will be read when
coverage measurement starts, and data will be saved automatically when
measurement stops.</p>
<p>If <cite>timid</cite> is true, then a slower and simpler trace function will be
used.  This is important for some environments where manipulation of
tracing functions breaks the faster trace function.</p>
<p>If <cite>branch</cite> is true, then branch coverage will be measured in addition
to the usual statement coverage.</p>
<p><cite>config_file</cite> determines what configuration file to read:</p>
<blockquote>
<div><ul class="simple">
<li>If it is &#8221;.coveragerc&#8221;, it is interpreted as if it were True,
for backward compatibility.</li>
<li>If it is a string, it is the name of the file to read.  If the
file can&#8217;t be read, it is an error.</li>
<li>If it is True, then a few standard files names are tried
(&#8221;.coveragerc&#8221;, &#8220;setup.cfg&#8221;).  It is not an error for these files
to not be found.</li>
<li>If it is False, then no configuration file is read.</li>
</ul>
</div></blockquote>
<p><cite>source</cite> is a list of file paths or package names.  Only code located
in the trees indicated by the file paths or package names will be
measured.</p>
<p><cite>include</cite> and <cite>omit</cite> are lists of filename patterns. Files that match
<cite>include</cite> will be measured, files that match <cite>omit</cite> will not.  Each
will also accept a single string argument.</p>
<p><cite>debug</cite> is a list of strings indicating what debugging information is
desired.</p>
<p><cite>concurrency</cite> is a string indicating the concurrency library being used
in the measured code.  Without this, coverage.py will get incorrect
results.  Valid strings are &#8220;greenlet&#8221;, &#8220;eventlet&#8221;, &#8220;gevent&#8221;, or
&#8220;thread&#8221; (the default).</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.0: </span>The <cite>concurrency</cite> parameter.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.analysis">
<code class="descname">analysis</code>(<em>morf</em>)<a class="headerlink" href="#coverage.Coverage.analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>analysis2</cite> but doesn&#8217;t return excluded line numbers.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.analysis2">
<code class="descname">analysis2</code>(<em>morf</em>)<a class="headerlink" href="#coverage.Coverage.analysis2" title="Permalink to this definition">¶</a></dt>
<dd><p>Analyze a module.</p>
<p><cite>morf</cite> is a module or a filename.  It will be analyzed to determine
its coverage statistics.  The return value is a 5-tuple:</p>
<ul class="simple">
<li>The filename for the module.</li>
<li>A list of line numbers of executable statements.</li>
<li>A list of line numbers of excluded statements.</li>
<li>A list of line numbers of statements not run (missing from
execution).</li>
<li>A readable formatted string of the missing line numbers.</li>
</ul>
<p>The analysis uses the source file itself and the current measured
coverage data.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.annotate">
<code class="descname">annotate</code>(<em>morfs=None</em>, <em>directory=None</em>, <em>ignore_errors=None</em>, <em>omit=None</em>, <em>include=None</em>)<a class="headerlink" href="#coverage.Coverage.annotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Annotate a list of modules.</p>
<p>Each module in <cite>morfs</cite> is annotated.  The source is written to a new
file, named with a &#8221;,cover&#8221; suffix, with each line prefixed with a
marker to indicate the coverage of the line.  Covered lines have &#8220;&gt;&#8221;,
excluded lines have &#8220;-&#8221;, and missing lines have &#8221;!&#8221;.</p>
<p>See <a class="reference internal" href="#coverage.Coverage.report" title="coverage.Coverage.report"><code class="xref py py-meth docutils literal"><span class="pre">report()</span></code></a> for other arguments.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.clear_exclude">
<code class="descname">clear_exclude</code>(<em>which='exclude'</em>)<a class="headerlink" href="#coverage.Coverage.clear_exclude" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the exclude list.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.combine">
<code class="descname">combine</code>(<em>data_paths=None</em>)<a class="headerlink" href="#coverage.Coverage.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine together a number of similarly-named coverage data files.</p>
<p>All coverage data files whose name starts with <cite>data_file</cite> (from the
coverage() constructor) will be read, and combined together into the
current measurements.</p>
<p><cite>data_paths</cite> is a list of files or directories from which data should
be combined. If no list is passed, then the data files from the
directory indicated by the current data file (probably the current
directory) will be combined.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.0: </span>The <cite>data_paths</cite> parameter.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.erase">
<code class="descname">erase</code>()<a class="headerlink" href="#coverage.Coverage.erase" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase previously-collected coverage data.</p>
<p>This removes the in-memory data collected in this session as well as
discarding the data file.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.exclude">
<code class="descname">exclude</code>(<em>regex</em>, <em>which='exclude'</em>)<a class="headerlink" href="#coverage.Coverage.exclude" title="Permalink to this definition">¶</a></dt>
<dd><p>Exclude source lines from execution consideration.</p>
<p>A number of lists of regular expressions are maintained.  Each list
selects lines that are treated differently during reporting.</p>
<p><cite>which</cite> determines which list is modified.  The &#8220;exclude&#8221; list selects
lines that are not considered executable at all.  The &#8220;partial&#8221; list
indicates lines with branches that are not taken.</p>
<p><cite>regex</cite> is a regular expression.  The regex is added to the specified
list.  If any of the regexes in the list is found in a line, the line
is marked for special treatment during reporting.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.get_data">
<code class="descname">get_data</code>()<a class="headerlink" href="#coverage.Coverage.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the collected data and reset the collector.</p>
<p>Also warn about various problems collecting data.</p>
<p>Returns a <a class="reference internal" href="/code/coverage/beta/api_coveragedata.html#coverage.CoverageData" title="coverage.CoverageData"><code class="xref py py-class docutils literal"><span class="pre">coverage.CoverageData</span></code></a>, the collected coverage data.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.get_exclude_list">
<code class="descname">get_exclude_list</code>(<em>which='exclude'</em>)<a class="headerlink" href="#coverage.Coverage.get_exclude_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of excluded regex patterns.</p>
<p><cite>which</cite> indicates which list is desired.  See <a class="reference internal" href="#coverage.Coverage.exclude" title="coverage.Coverage.exclude"><code class="xref py py-meth docutils literal"><span class="pre">exclude()</span></code></a> for the
lists that are available, and their meaning.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.get_option">
<code class="descname">get_option</code>(<em>option_name</em>)<a class="headerlink" href="#coverage.Coverage.get_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an option from the configuration.</p>
<p><cite>option_name</cite> is a colon-separated string indicating the section and
option name.  For example, the <code class="docutils literal"><span class="pre">branch</span></code> option in the <code class="docutils literal"><span class="pre">[run]</span></code>
section of the config file would be indicated with <cite>&#8220;run:branch&#8221;</cite>.</p>
<p>Returns the value of the option.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.html_report">
<code class="descname">html_report</code>(<em>morfs=None</em>, <em>directory=None</em>, <em>ignore_errors=None</em>, <em>omit=None</em>, <em>include=None</em>, <em>extra_css=None</em>, <em>title=None</em>)<a class="headerlink" href="#coverage.Coverage.html_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an HTML report.</p>
<p>The HTML is written to <cite>directory</cite>.  The file &#8220;index.html&#8221; is the
overview starting point, with links to more detailed pages for
individual modules.</p>
<p><cite>extra_css</cite> is a path to a file of other CSS to apply on the page.
It will be copied into the HTML directory.</p>
<p><cite>title</cite> is a text string (not HTML) to use as the title of the HTML
report.</p>
<p>See <a class="reference internal" href="#coverage.Coverage.report" title="coverage.Coverage.report"><code class="xref py py-meth docutils literal"><span class="pre">report()</span></code></a> for other arguments.</p>
<p>Returns a float, the total percentage covered.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.load">
<code class="descname">load</code>()<a class="headerlink" href="#coverage.Coverage.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load previously-collected coverage data from the data file.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.report">
<code class="descname">report</code>(<em>morfs=None</em>, <em>show_missing=True</em>, <em>ignore_errors=None</em>, <em>file=None</em>, <em>omit=None</em>, <em>include=None</em>, <em>skip_covered=False</em>)<a class="headerlink" href="#coverage.Coverage.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a summary report to <cite>file</cite>.</p>
<p>Each module in <cite>morfs</cite> is listed, with counts of statements, executed
statements, missing statements, and a list of lines missed.</p>
<p><cite>include</cite> is a list of filename patterns.  Files that match will be
included in the report. Files matching <cite>omit</cite> will not be included in
the report.</p>
<p>Returns a float, the total percentage covered.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.save">
<code class="descname">save</code>()<a class="headerlink" href="#coverage.Coverage.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the collected coverage data to the data file.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.set_option">
<code class="descname">set_option</code>(<em>option_name</em>, <em>value</em>)<a class="headerlink" href="#coverage.Coverage.set_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Set an option in the configuration.</p>
<p><cite>option_name</cite> is a colon-separated string indicating the section and
option name.  For example, the <code class="docutils literal"><span class="pre">branch</span></code> option in the <code class="docutils literal"><span class="pre">[run]</span></code>
section of the config file would be indicated with <code class="docutils literal"><span class="pre">&quot;run:branch&quot;</span></code>.</p>
<p><cite>value</cite> is the new value for the option.  This should be a Python
value where appropriate.  For example, use True for booleans, not the
string <code class="docutils literal"><span class="pre">&quot;True&quot;</span></code>.</p>
<p>As an example, calling:</p>
<code lang="python">cov.set_option(&quot;run:branch&quot;, True)</code>
<p>has the same effect as this configuration file:</p>
<code lang="python">[run]
branch = True</code>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.start">
<code class="descname">start</code>()<a class="headerlink" href="#coverage.Coverage.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start measuring code coverage.</p>
<p>Coverage measurement actually occurs in functions called after
<a class="reference internal" href="#coverage.Coverage.start" title="coverage.Coverage.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> is invoked.  Statements in the same scope as
<a class="reference internal" href="#coverage.Coverage.start" title="coverage.Coverage.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a> won&#8217;t be measured.</p>
<p>Once you invoke <a class="reference internal" href="#coverage.Coverage.start" title="coverage.Coverage.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a>, you must also call <a class="reference internal" href="#coverage.Coverage.stop" title="coverage.Coverage.stop"><code class="xref py py-meth docutils literal"><span class="pre">stop()</span></code></a>
eventually, or your process might not shut down cleanly.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.stop">
<code class="descname">stop</code>()<a class="headerlink" href="#coverage.Coverage.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop measuring code coverage.</p>
</dd></dl>

<dl class="method">
<dt id="coverage.Coverage.xml_report">
<code class="descname">xml_report</code>(<em>morfs=None</em>, <em>outfile=None</em>, <em>ignore_errors=None</em>, <em>omit=None</em>, <em>include=None</em>)<a class="headerlink" href="#coverage.Coverage.xml_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an XML report of coverage results.</p>
<p>The report is compatible with Cobertura reports.</p>
<p>Each module in <cite>morfs</cite> is included in the report.  <cite>outfile</cite> is the
path to write the file to, &#8220;-&#8221; will write to stdout.</p>
<p>See <a class="reference internal" href="#coverage.Coverage.report" title="coverage.Coverage.report"><code class="xref py py-meth docutils literal"><span class="pre">report()</span></code></a> for other arguments.</p>
<p>Returns a float, the total percentage covered.</p>
</dd></dl>

</dd></dl>

<h1>Starting coverage.py automatically<a class="headerlink" href="#starting-coverage-py-automatically" title="Permalink to this headline">¶</a></h1>
<p>This function is used to start coverage measurement automatically when Python
starts.  See <a class="reference internal" href="/code/coverage/beta/subprocess.html#subprocess"><span>Measuring sub-processes</span></a> for details.</p>
<dl class="function">
<dt id="coverage.process_startup">
<code class="descclassname">coverage.</code><code class="descname">process_startup</code>()<a class="headerlink" href="#coverage.process_startup" title="Permalink to this definition">¶</a></dt>
<dd><p>Call this at Python start-up to perhaps measure coverage.</p>
<p>If the environment variable COVERAGE_PROCESS_START is defined, coverage
measurement is started.  The value of the variable is the config file
to use.</p>
<p>There are two ways to configure your Python installation to invoke this
function when Python starts:</p>
<ol class="arabic">
<li><p class="first">Create or append to sitecustomize.py to add these lines:</p>
<code lang="python">import coverage
coverage.process_startup()</code>
</li>
<li><p class="first">Create a .pth file in your Python installation containing:</p>
<code lang="python">import coverage; coverage.process_startup()</code>
</li>
</ol>
</dd></dl>



<p class='pmn pmnbot'>
    <span class='p'>&#xab;&#xa0;<i>Previous:</i> <a href="/code/coverage/beta/api.html" title="previous topic">Coverage.py API</a></span>
    <span class='n'><i>Next:</i> <a href="/code/coverage/beta/api_coveragedata.html" title="next topic">The CoverageData class</a>&#xa0;&#xbb;</span>
</p>

</page>