<?xml version="1.0" encoding="utf-8" ?>

<page title='Branch coverage measurement' >

  <history>
<what when='20091127T201300'>new for version 3.2</what>
<what when='20100725T211700'>updated for 3.4.</what>
<what when='20110604T181700'>updated for 3.5.</what>
<what when='20111214T181800'>Fix a bug that Guido pointed out.</what>
</history>
<p>In addition to the usual statement coverage, Coverage.py also supports branch
coverage measurement. Where a line in your program could jump to more than one
next line, coverage.py tracks which of those destinations are actually visited,
and flags lines that haven&#8217;t visited all of their possible destinations.</p>
<p>For example:</p>
<code lang="python">def my_partial_fn(x):       # line 1
    if x:                   #      2
        y = 10              #      3
    return y                #      4

my_partial_fn(1)</code>
<p>In this code, line 2 is an <tt class="docutils literal"><span class="pre">if</span></tt> statement which can go next to either line 3
or line 4. Statement coverage would show all lines of the function as executed.
But the if was never evaluated as false, so line 2 never jumps to line 4.</p>
<p>Branch coverage will flag this code as not fully covered because of the missing
jump from line 2 to line 4.  This is known as a partial branch.</p>
<h1>How to measure branch coverage</h1>
<p>To measure branch coverage, run coverage.py with the <tt class="docutils literal"><span class="pre">--branch</span></tt> flag:</p>
<code lang="python">coverage run --branch myprog.py</code>
<p>When you report on the results with <tt class="docutils literal"><span class="pre">coverage</span> <span class="pre">report</span></tt> or <tt class="docutils literal"><span class="pre">coverage</span> <span class="pre">html</span></tt>,
the percentage of branch possibilities taken will be included in the percentage
covered total for each file.  The coverage percentage for a file is the actual
executions divided by the execution opportunities.  Each line in the file is an
execution opportunity, as is each branch destination.</p>
<p>The HTML report gives information about which lines had missing branches. Lines
that were missing some branches are shown in yellow, with an annotation at the
far right showing branch destination line numbers that were not exercised.</p>
<p>The XML report produced by <tt class="docutils literal"><span class="pre">coverage</span> <span class="pre">xml</span></tt> also includes branch information,
including separate statement and branch coverage percentages.</p>
<h1>How it works</h1>
<p>When measuring branches, coverage.py collects pairs of line numbers, a source
and destination for each transition from one line to another.  Static analysis
of the compiled bytecode provides a list of possible transitions.  Comparing
the measured to the possible indicates missing branches.</p>
<p>The idea of tracking how lines follow each other was from <a class="reference external" href="http://ivory.idyll.org/blog">Titus Brown</a>.
Thanks, Titus!</p>
<h1>Excluding code</h1>
<p>If you have <a class="reference internal" href="/code/coverage/excluding.html#excluding"><em>excluded code</em></a>, a condtional will not be
counted as a branch if one of its choices is excluded:</p>
<code lang="python">def only_one_choice(x):
    if x:
        blah1()
        blah2()
    else:       # pragma: no cover
        # x is always true.
        blah3()</code>
<p>Because the <tt class="docutils literal"><span class="pre">else</span></tt> clause is excluded, the <tt class="docutils literal"><span class="pre">if</span></tt> only has one possible
next line, so it isn&#8217;t considered a branch at all.</p>
<h1>Structurally partial branches</h1>
<p>Sometimes branching constructs are used in unusual ways that don&#8217;t actually
branch.  For example:</p>
<code lang="python">while True:
    if cond:
        break
    do_something()</code>
<p>Here the while loop will never exit normally, so it doesn&#8217;t take both of its
&#8220;possible&#8221; branches.  For some of these constructs, such as &#8220;while True:&#8221; and
&#8220;if 0:&#8221;, coverage.py understands what is going on.  In these cases, the line
will not be marked as a partial branch.</p>
<p>But there are many ways in your own code to write intentionally partial
branches, and you don&#8217;t want coverage.py pestering you about them.  You can
tell coverage.py that you don&#8217;t want them flagged by marking them with a
pragma:</p>
<code lang="python">i = 0
while i &lt; 999999999:    # pragma: no branch
    if eventually():
        break</code>
<p>Here the while loop will never complete because the break will always be taken
at some point.  Coverage.py can&#8217;t work that out on its own, but the
&#8220;no branch&#8221; pragma indicates that the branch is known to be partial, and
the line is not flagged.</p>


<p class='pmn pmnbot'>
    <span class='p'>&#xab;&#xa0;<i>Previous:</i> <a href="/code/coverage/excluding.html" title="previous topic">Excluding code from coverage</a></span>
    <span class='n'><i>Next:</i> <a href="/code/coverage/subprocess.html" title="next topic">Measuring subprocesses</a>&#xa0;&#xbb;</span>
</p>

</page>